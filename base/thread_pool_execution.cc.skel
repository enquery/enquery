// Copyright 2015 The Enquery Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License. See the AUTHORS file for names of
// contributors.

#include "enquery/thread_pool_execution.h"
#include <assert.h>
#include <pthread.h>
#include <stdio.h>
#include <string.h>
#include <deque>
#include <vector>
#include "enquery/scope_lock.h"
#include "enquery/scope_pointer.h"
#include "enquery/status.h"
#include "enquery/thread.h"
#include "enquery/utility.h"

// The ThreadPoolExecution class provides an implementation of Execution
// that schedules Task objects to execute on a pool of threads. Each
// instance owns a single TaskQueue and multiple Worker instances, all
// of which share the TaskQueue. When a task is scheduled for execution,
// it is placed onto the queue and executed by the first available Worker
// thread.
//
// ThreadPoolExecution guarantees that all tasks that have been queued
// will be executed prior to shutdown. This is

namespace enquery {

class ThreadPoolExecution::Rep {
 public:
  Rep() {
  }

  virtual ~Rep() {
  }

  Status Init(const ThreadPoolExecution::Settings& settings) {
    const int thread_count = settings.thread_count();
    if (thread_count <= 0) {
      return Status::MakeError("ThreadPoolExecution::Rep",
                               "thread count must be greater than zero");
    }
    return Status::OK();
  }

  Status Execute(Task* task) {
    if (task == NULL) {
      return Status::MakeError("ThreadPoolExecution::Rep",
                               "task object was null");
    }
    task->Run();
    delete task;
    return Status::OK();
  }

  void Shutdown() {
  }
};

ThreadPoolExecution::ThreadPoolExecution(Rep* rep) : rep_(rep) {
  assert(rep != NULL);
}

ThreadPoolExecution::~ThreadPoolExecution() { delete rep_; }

Execution* ThreadPoolExecution::Create(const Settings& settings,
                                       Status* status_out) {
  ScopePointer<Rep> rep(new Rep());
  Status status = rep->Init(settings);
  if (status.IsFailure()) {
    MaybeAssign(status_out, status);
    return NULL;
  }

  ThreadPoolExecution* execution = new ThreadPoolExecution(rep.Get());
  rep.ReleaseOwnership();

  return execution;
}

ThreadPoolExecution::Settings ThreadPoolExecution::DefaultSettings() {
  return Settings();
}

Status ThreadPoolExecution::Execute(Task* task) { return rep_->Execute(task); }

void ThreadPoolExecution::Shutdown() { rep_->Shutdown(); }

}  // namespace enquery
